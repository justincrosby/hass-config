# Pyscript for Home Assistant - Language Limitations and Guidelines

## Critical Overview
Pyscript is a special Python interpreter built for Home Assistant that runs fully-async in the main HASS event loop. While it implements most Python features, there are important limitations and exceptions you must understand.

## All Functions are Async
- **All pyscript functions are inherently async**
- `async` and `await` are **optional** in pyscript - the interpreter automatically detects whether functions are real or async and calls them correctly
- **Preference: Omit `async` and `await` keywords** - they are not necessary and make code less clean
- Just call functions directly: `light.turn_on(...)` instead of `await light.turn_on(...)`
- Just declare functions normally: `def my_func():` instead of `async def my_func():`
- If you declare a function as `async def`, it doesn't behave like a true Python async function and may cause unexpected behavior
- If you truly need true async function behavior, use the `@pyscript_compile` decorator

## Identifier Handling with Periods
- Pyscript treats function names and state names containing periods (e.g., `pyscript.reload`, `state.get`) as plain identifiers, NOT as object attribute access
- These are special built-in functions: `pyscript.*` and `state.*`
- **Important:** If you assign a value to `pyscript` or `state` as a variable, you lose access to the built-in functions
- Example: If you do `pyscript = some_value`, then `pyscript.reload` no longer calls the reload function

## Python Module Callbacks
- **Do not pass pyscript functions as callbacks to Python modules** (without special handling)
- Pyscript functions are async, but Python modules expect regular (non-async) functions
- Python modules cannot call async functions unless explicitly designed to use `await`
- **Workarounds:**
  - Use the `@pyscript_compile` decorator to compile functions to native Python
  - Use lambda functions (which are also compiled)
  - Write your callback class/function in native Python and import it

## Class Special Methods Not Supported
- Special methods like `__eq__`, `__str__`, etc. will not work in pyscript classes
- These methods are async and Python cannot call them
- **Workarounds:**
  - Use `@pyscript_compile` decorator on methods to compile them to native Python
  - Write your class in native Python and import it into pyscript

## Thread Safety
- **Pyscript and HASS primitives are NOT thread-safe**
- Only run pyscript code in the main event loop
- Use `task.executor()` to safely run regular Python code in a separate thread
- The `threading` package is untested but may work if threads only run regular Python code
- **Never call pyscript functions from threads you create** - this will cause errors

## Unsupported Language Features
- ❌ Generators and the `yield` statement
- ❌ The `match-case` statement
- ❌ Built-in I/O functions: `open()`, `read()`, `write()`
  - These are blocked to prevent I/O in the main event loop and for security
  - `print()` only logs messages (doesn't support file handles or other features)
- ❌ Built-in function decorators used inline (e.g., `state_trigger` as a decorator call)
  - You can define custom function decorators, but built-in decorators must be used in the proper context

## Import Limitations
- Complex packages may fail to import
- **Workaround:** Import the module in a native Python file, then import that shim module into pyscript

## Best Practices for This Directory
1. **Omit `async` and `await` keywords** - they are optional and code is cleaner without them
   - Use: `light.turn_on(...)` instead of `await light.turn_on(...)`
   - Use: `def my_func():` instead of `async def my_func():`
   - Use: `task.sleep(1)` instead of `await task.sleep(1)`
2. Don't reassign `pyscript` or `state` variables
3. Keep all code in the main event loop (don't spawn threads calling pyscript functions)
4. For complex callbacks or special methods, prefer native Python imports
5. Use `@pyscript_compile` when you need true Python behavior for callbacks or special methods
